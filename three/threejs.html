<!doctype html>
<html>

<head>
    <title>My first Three.js app</title>
    <style>
        body { margin: 0; }
        			canvas { width: 100%; height: 100% }
    </style>
</head>

<body>
    <div id="ThreeJScontainer"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
    <script src="http://mrdoob.github.io/three.js/examples/js/renderers/Projector.js"></script>
    <script src="http://mrdoob.github.io/three.js/examples/js/controls/OrthographicTrackballControls.js"></script>
    <script src="http://mrdoob.github.io/three.js/examples/js/libs/stats.min.js"></script>
    <script>
            var controls;
			var container;
			var camera, scene, renderer;
			var plane, cube;
			var mouse, raycaster, isShiftDown = false;

			var rollOverMesh, rollOverMaterial;
			var cubeGeo, cubeMaterial;

			var objects = [];

			init();
			render();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> - voxel painter - webgl<br><strong>click</strong>: add voxel, <strong>shift + click</strong>: remove voxel';
				container.appendChild( info );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 500, 800, 1300 );
				camera.lookAt( new THREE.Vector3() );
                controls = new THREE.OrthographicTrackballControls(camera);
                controls.damping = 1.2;
                controls.addEventListener("change", render);
				scene = new THREE.Scene();

				// roll-over helpers

				rollOverGeo = new THREE.BoxGeometry( 50, 50, 50 );
				rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
				rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
				scene.add( rollOverMesh );

				// cubes

				cubeGeo = new THREE.BoxGeometry( 50, 50, 50 );
				cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xfeb74c, ambient: 0x00ff80, shading: THREE.FlatShading } );
				cubeMaterial.ambient = cubeMaterial.color;

				// grid

				var size = 500, step = 50;

				var geometry = new THREE.Geometry();

				for ( var i = - size; i <= size; i += step ) {

					geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
					geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );

					geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
					geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );

				}

				var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2, transparent: true } );

				var line = new THREE.Line( geometry, material, THREE.LinePieces );
				scene.add( line );

				//

				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();

				var geometry = new THREE.PlaneBufferGeometry( 1000, 1000 );
				geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

				plane = new THREE.Mesh( geometry );
				plane.visible = false;
				scene.add( plane );

				objects.push( plane );

				// Lights

				var ambientLight = new THREE.AmbientLight( 0x606060 );
				scene.add( ambientLight );

				var directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
				scene.add( directionalLight );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'keydown', onDocumentKeyDown, false );
				document.addEventListener( 'keyup', onDocumentKeyUp, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					var intersect = intersects[ 0 ];

					rollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );
					rollOverMesh.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );

				}

				render();

			}

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					var intersect = intersects[ 0 ];

					// delete cube

					if ( isShiftDown ) {

						if ( intersect.object != plane ) {

							scene.remove( intersect.object );

							objects.splice( objects.indexOf( intersect.object ), 1 );

						}

					// create cube

					} else {

						var voxel = new THREE.Mesh( cubeGeo, cubeMaterial );
						voxel.position.copy( intersect.point ).add( intersect.face.normal );
						voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
						scene.add( voxel );

						objects.push( voxel );

					}

					render();

				}

			}

			function onDocumentKeyDown( event ) {

				switch( event.keyCode ) {

					case 16: isShiftDown = true; break;

				}

			}

			function onDocumentKeyUp( event ) {

				switch ( event.keyCode ) {

					case 16: isShiftDown = false; break;

				}

			}

			function render() {

				renderer.render( scene, camera );

			}
    </script>
    <!--<script>
        var container, scene, camera, camera2, renderer;
        init();
        animate();
         // FUNCTIONS //
        function init() {
            scene = new THREE.Scene();
            // CAMERA //
            var SCREEN_WIDTH = window.innerWidth,
                SCREEN_HEIGHT = window.innerHeight;
            var VIEW_ANGLE = 110,
                ASPECT = (0.5 * SCREEN_WIDTH) / SCREEN_HEIGHT,
                NEAR = 0.1,
                FAR = 20000;
            camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
            camera2 = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
            scene.add(camera);
            scene.add(camera2);
            
            camera.position.set(0, 0, 500);
            camera2.position.set(0, 500, 0);
            
            camera.lookAt(scene.position);
            camera2.lookAt(scene.position);
            // RENDERER NEW
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
            renderer.setClearColor( 0xff00ff );
            //...Either create a div element to contain the renderer        ==> container = document.createElement( 'div' );
            container = document.getElementById('ThreeJScontainer'); //...OR reference predefined container in the html
            container.appendChild(renderer.domElement);
            //Hmmmm   THREEx.WindowResize(renderer, camera);
            var light = new THREE.PointLight(0xffffff, 1);
            light.position.set(0, 250, 0);
            scene.add(light);
            var ambientLight = new THREE.AmbientLight(0x404040);
            //ambientLight.position.set(0, 500, 0);
            scene.add(ambientLight);
            var sphereGeometry = new THREE.BoxGeometry(50, 50, 50);
            // use a "lambert" material rather than "basic" for realistic lighting.//(don't forget to add >= 1 light!)
            var sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff
            });
            var sphere1 = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere1.position.set(-60, 0, 50);
            scene.add(sphere1);
            var sphere2 = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere2.position.set(0, 0, -50);
            scene.add(sphere2);
            var sphere3 = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere3.position.set(60, 0, 50);
            scene.add(sphere3);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            var SCREEN_WIDTH = window.innerWidth,
                SCREEN_HEIGHT = window.innerHeight;
            camera.aspect = (0.5 * SCREEN_WIDTH) / SCREEN_HEIGHT;
            camera.updateProjectionMatrix();
            camera2.aspect = (0.5 * SCREEN_WIDTH) / SCREEN_HEIGHT;
            camera2.updateProjectionMatrix();
            var mar = 100
            var panelX1min = mar
            var panelWidth = Math.floor(0.5 * SCREEN_WIDTH) - (2 * mar)
            var panelX2min = panelWidth + 3*mar;
            var panelYmin = mar;
            var panelHeight = SCREEN_HEIGHT - (2 * mar)
            //...LEFT SIDE 
            renderer.setViewport(1, 1, 0.5 * SCREEN_WIDTH -2, SCREEN_HEIGHT - 2);
            renderer.render(scene, camera);
            renderer.autoClear = false;
            //...RIGHT SIDE

            // ***** if you comment out the next two lines then the left side viewport will be shown *****

            renderer.setViewport(0.5 * SCREEN_WIDTH, 1, 0.5 * SCREEN_WIDTH - 2, SCREEN_HEIGHT - 2);
            renderer.render(scene, camera2);
        }
    </script>-->
</body>

</html>